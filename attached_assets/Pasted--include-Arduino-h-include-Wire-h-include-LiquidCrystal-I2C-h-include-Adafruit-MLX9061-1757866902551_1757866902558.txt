#include <Arduino.h> 
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Adafruit_MLX90614.h>
#include "MAX30105.h"
#include "heartRate.h"
#include "spo2_algorithm.h"
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <WiFiManager.h>     // Portal konfigurasi WiFi dari HP
#include <math.h>
#include <time.h>            // NTP time support

// ==================== FIREBASE (RTDB REST) ====================
const String FIREBASE_HOST = "monitoring-jantung-f8031-default-rtdb.firebaseio.com";
// NOTE: untuk produksi sebaiknya pakai token (idToken) per-perangkat, ini disederhanakan agar cepat jalan.
const String FIREBASE_AUTH = "AIzaSyC_4FizusMK9ksaWcYXBmubsp3GGxuuX0g";
const String DEVICE_ID     = "ESP32_Monitor_Jantung";

// ==================== NTP SETTINGS ====================
const char* ntpServer          = "pool.ntp.org";
const long  gmtOffset_sec      = 25200; // UTC+7
const int   daylightOffset_sec = 0;

// ==================== KALIBRASI MEDIS ====================
const int KALIBRASI_SISTOLIK  = -15;
const int KALIBRASI_DIASTOLIK = -10;

// ==================== PIN & SERIAL ====================
#define TOMBOL_PIN 4
#define RXD2 16
#define TXD2 17

// ==================== LCD & SENSOR ====================
LiquidCrystal_I2C lcd(0x27, 20, 4);
Adafruit_MLX90614 mlx = Adafruit_MLX90614();
MAX30105 sensorDetak;

// ==================== STATUS SISTEM ====================
bool wifiTerhubung = false;
bool firebaseSiap  = false;
bool ntpSinkron    = false;

// ==================== VAR TEKANAN DARAH (Serial2) ====================
char buff[64];
bool b_read, b_discard;
char discard;
int  i, j = 0;
char final_buff[64];

int   nilaiSistolik = 0, nilaiDiastolik = 0, nilaiDetakDarah = 0;
float suhuTubuh     = 0.0;

// ==================== VAR DETAK & SpO2 ====================
#define UKURAN_BUFFER 100
uint32_t bufferIR[UKURAN_BUFFER];
uint32_t bufferMerah[UKURAN_BUFFER];

const int durasi_ms = 30000;   // 30 detik untuk BPM & SpO2
long  lastBeat = 0;
float beatsPerMinute = 0;
int   bpm_final = 0;

int32_t spo2, heartRate;
int8_t  spo2Valid, heartRateValid;
int     spo2Final = 0;
int     detakJantungFinal = 0;

// ==================== FALLBACK DATA ====================
float suhuFallback   = 36.5;
int   detakFallback  = 75;
int   spo2Fallback   = 98;
int   sistolikFallback  = 120;
int   diastolikFallback = 80;

// ==================== WiFiManager CONFIG ====================
#define CONFIG_AP_SSID  "ESP32-Monitor"
#define CONFIG_AP_PASS  "12345678"
#define CONFIG_PORTAL_TIMEOUT_SEC 180

// ==================== GAUSSIAN NAIVE BAYES (dari RTDB) ====================
// Model yang kamu upload: naive_bayes_model.json
// Struktur:
// {
//   "prior": {"1":0.55,"0":0.36,"2":0.088},
//   "means": {"0":{"Suhu Tubuh (C)":...,"Detak Jantung":...,"Sistolik":...,"Diastolik":...,"Saturasi Oksigen":...}, "1": {...}, "2": {...}},
//   "std":   {"0":{...}, "1":{...}, "2":{...}}
// }
static const int NB_NUM_CLASSES = 3;
static const int NB_NUM_FEATS   = 5;  // Suhu, HR, SYS, DIA, SpO2

// Urutan fitur (HARUS sama saat parsing JSON)
enum FeatIdx { F_TEMP=0, F_HR=1, F_SYS=2, F_DIA=3, F_SPO2=4 };

// Pemetaan ID kelas -> label akhir (sesuai permintaan)
// Berdasar kebiasaan model: "1" prior terbesar (Normal), "0" (Kurang Normal), "2" (Berbahaya).
String classIdToLabel(int cid) {
  if (cid == 1) return "Normal";
  if (cid == 0) return "Kurang Normal";
  return "Berbahaya"; // cid == 2
}

float nbLogPrior[NB_NUM_CLASSES] = { logf(0.36f), logf(0.55f), logf(0.088f) }; // akan di-override dari RTDB
float nbMean[NB_NUM_CLASSES][NB_NUM_FEATS] = {0};
float nbStd [NB_NUM_CLASSES][NB_NUM_FEATS] = {1,1,1,1,1,
                                              1,1,1,1,1,
                                              1,1,1,1,1};
bool  nbLoaded = false;
String nbLabel = "Normal";

// ==================== PROTOTIPE ====================
void connectWiFiViaManager();
void setupNTPTime();
void setupFirebase();
void setupSensorSempurna();
void tampilkanStatus();
void ukurSuhuTubuh();
void ukurDetakJantungFixed();
void ukurKadarOksigen();
void ukurTekananDarahFixed();
void tampilkanHasil();
String getStatusKesehatan();

void kirimDataKeFirebaseFixed();
String withAuth(const String& path);
unsigned long getNTPTime();
String getNTPTimestamp();

int   hexDigit(char c);
int   hexToDec(char high, char low);

// NB:
bool  loadNBModelFromFirebase(); // baca naive_bayes_model.json dari RTDB
float logGaussian(float x, float mu, float sigma);
int   argmax3(float a, float b, float c);
String predictNB_Gaussian(float t, int bpm, int sys, int dia, int sO2);

// ==================== SETUP ====================
void setup() {
  Serial.begin(115200);
  Serial2.begin(115200, SERIAL_8N1, RXD2, TXD2);
  Wire.begin();
  pinMode(TOMBOL_PIN, INPUT_PULLUP);
  randomSeed(esp_random());

  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Monitor Kesehatan");
  lcd.setCursor(0, 1);
  lcd.print("Init...");

  Serial.println("\n=== MONITOR + Gaussian Naive Bayes (RTDB) ===");

  connectWiFiViaManager();

  if (wifiTerhubung) {
    setupNTPTime();
    setupFirebase();
    if (firebaseSiap) {
      nbLoaded = loadNBModelFromFirebase();
      Serial.println(nbLoaded ? "Model NB: termuat dari RTDB" : "Model NB: pakai default firmware");
    }
  }

  setupSensorSempurna();
  tampilkanStatus();
}

// ==================== LOOP ====================
void loop() {
  if (digitalRead(TOMBOL_PIN) == LOW) {
    delay(300);

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Mulai Pengukuran");
    lcd.setCursor(0, 1);
    lcd.print("Mohon tunggu...");
    delay(1000);

    ukurSuhuTubuh();
    delay(400);
    ukurDetakJantungFixed();
    delay(400);
    ukurKadarOksigen();
    delay(400);
    ukurTekananDarahFixed();
    delay(400);

    // === Prediksi Naive Bayes Gaussian (5 fitur) ===
    nbLabel = predictNB_Gaussian(suhuTubuh, detakJantungFinal, nilaiSistolik, nilaiDiastolik, spo2Final);

    tampilkanHasil();

    if (wifiTerhubung && firebaseSiap) {
      kirimDataKeFirebaseFixed();
    } else {
      Serial.println("Mode offline - data tersimpan lokal");
      lcd.setCursor(0, 3);
      lcd.print("Mode: Offline    ");
      delay(900);
    }

    tampilkanStatus();
    delay(600);
  }

  delay(40);
}

// ==================== WIFI MANAGER ====================
void connectWiFiViaManager() {
  unsigned long t0 = millis();
  bool mauReset = false;
  if (digitalRead(TOMBOL_PIN) == LOW) {
    while (millis() - t0 < 5000) {
      if (digitalRead(TOMBOL_PIN) == HIGH) break;
      delay(10);
    }
    if (millis() - t0 >= 5000) mauReset = true;
  }

  WiFi.mode(WIFI_STA);
  WiFiManager wm;
  if (mauReset) {
    wm.resetSettings();
    Serial.println("Reset kredensial WiFi. Buka portal...");
  }
  wm.setConfigPortalTimeout(CONFIG_PORTAL_TIMEOUT_SEC);

  lcd.setCursor(0, 1); lcd.print("WiFi cfg via HP  ");
  lcd.setCursor(0, 2); lcd.print("AP: ESP32-Monitor");

  bool res = wm.autoConnect(CONFIG_AP_SSID, CONFIG_AP_PASS);

  if (res) {
    wifiTerhubung = true;
    Serial.println("WiFi terhubung. IP: " + WiFi.localIP().toString());
    lcd.setCursor(0, 1); lcd.print("WiFi: Terhubung  ");
    lcd.setCursor(0, 2); lcd.print(WiFi.localIP().toString() + "    ");
  } else {
    wifiTerhubung = false;
    Serial.println("Gagal WiFi");
    lcd.setCursor(0, 1); lcd.print("WiFi: Gagal      ");
    lcd.setCursor(0, 2); lcd.print("Buka portal lg   ");
  }
  delay(700);
}

// ==================== NTP ====================
void setupNTPTime() {
  lcd.setCursor(0, 3); lcd.print("Sync NTP time... ");
  Serial.println("Sync NTP...");

  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

  struct tm timeinfo;
  int attempts = 0;
  while (!getLocalTime(&timeinfo) && attempts < 10) {
    delay(800);
    attempts++;
  }

  if (getLocalTime(&timeinfo)) {
    ntpSinkron = true;
    Serial.println("NTP: OK");
    lcd.setCursor(0, 3); lcd.print("NTP: OK          ");
  } else {
    ntpSinkron = false;
    Serial.println("NTP: Gagal");
    lcd.setCursor(0, 3); lcd.print("NTP: Gagal       ");
  }
  delay(500);
}

unsigned long getNTPTime() {
  time_t now; time(&now);
  return (unsigned long)now * 1000UL; // ms
}

String getNTPTimestamp() {
  if (!ntpSinkron) {
    unsigned long totalDetik = millis() / 1000;
    int jam   = (totalDetik / 3600) % 24;
    int menit = (totalDetik / 60) % 60;
    int detik = totalDetik % 60;
    char waktuStr[10];
    sprintf(waktuStr, "%02d:%02d:%02d", jam, menit, detik);
    return String(waktuStr);
  }
  struct tm timeinfo;
  if(!getLocalTime(&timeinfo)) return "NTP Error";
  char buf[32];
  strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", &timeinfo);
  return String(buf);
}

// ==================== FIREBASE TEST ====================
void setupFirebase() {
  lcd.setCursor(0, 3); lcd.print("Tes Firebase...  ");
  WiFiClientSecure client; client.setInsecure();
  HTTPClient http;
  String testUrl = withAuth("/tes_koneksi.json");

  if (!http.begin(client, testUrl)) {
    firebaseSiap = false;
    lcd.setCursor(0, 3); lcd.print("Firebase: Gagal  ");
    return;
  }

  http.addHeader("Content-Type", "application/json");
  String testData = "\"tes_" + String(millis()) + "\"";
  int kodeResponse = http.PUT(testData);
  if (kodeResponse > 0 && (kodeResponse == 200 || kodeResponse == 204)) {
    firebaseSiap = true;
    lcd.setCursor(0, 3); lcd.print("Firebase: OK     ");
  } else {
    firebaseSiap = false;
    lcd.setCursor(0, 3); lcd.print("Firebase: Gagal  ");
  }
  http.end();

  // hapus tes (best effort)
  if (firebaseSiap) {
    if (http.begin(client, testUrl)) { http.sendRequest("DELETE"); http.end(); }
  }
}

// ==================== SENSOR INIT ====================
void setupSensorSempurna() {
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Siapkan sensor...");

  bool mlxBerhasil = false;
  for (int coba = 0; coba < 3; coba++) {
    if (mlx.begin()) { mlxBerhasil = true; break; }
    delay(200);
  }
  if (mlxBerhasil) { lcd.setCursor(0, 1); lcd.print("Sensor suhu: OK   "); }
  else             { lcd.setCursor(0, 1); lcd.print("Suhu: Fallback    "); }

  bool maxBerhasil = false;
  for (int coba = 0; coba < 3; coba++) {
    if (sensorDetak.begin(Wire, I2C_SPEED_STANDARD)) { maxBerhasil = true; break; }
    delay(200);
  }
  if (maxBerhasil) {
    sensorDetak.setup();
    sensorDetak.setPulseAmplitudeRed(0x3F);
    sensorDetak.setPulseAmplitudeIR(0x3F);
    lcd.setCursor(0, 2); lcd.print("Detak/SpO2: OK    ");
  } else {
    lcd.setCursor(0, 2); lcd.print("Detak: Fallback   ");
  }

  lcd.setCursor(0, 3); lcd.print("Semua: Siap       ");
  delay(600);
}

// ==================== STATUS LCD ====================
void tampilkanStatus() {
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Monitor Siap      ");
  lcd.setCursor(0, 1); lcd.print("WiFi: "); lcd.print(wifiTerhubung ? "OK     " : "Offline");
  lcd.setCursor(0, 2); lcd.print("NTP: ");  lcd.print(ntpSinkron ? "Sync    " : "Manual ");
  lcd.setCursor(0, 3); lcd.print("Tekan tombol biru ");
}

// ==================== UKUR SUHU (sinkron Serial & LCD) ====================
void ukurSuhuTubuh() {
  unsigned long mulai = millis();
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Ukur suhu tubuh   ");

  float totalSuhu = 0.0f;
  int   hitungSuhu = 0;
  bool  sensorOK = false;
  unsigned long lastPrint = 0;

  Serial.println("=== SUHU TUBUH (15s) ===");

  while (millis() - mulai < 15000) {
    float s = mlx.readObjectTempC();
    if (s > 10.0 && s < 50.0) { totalSuhu += s; hitungSuhu++; sensorOK = true; }
    else                      { sensorOK = false; }

    suhuTubuh = (hitungSuhu > 0) ? (totalSuhu / hitungSuhu) : suhuFallback;

    if (millis() - lastPrint >= 1000) {
      lastPrint = millis();
      lcd.setCursor(0, 1); lcd.print("Suhu: " + String(suhuTubuh, 1) + "C    ");
      lcd.setCursor(0, 2); lcd.print("Waktu: " + String((millis() - mulai) / 1000) + "/15s ");
      lcd.setCursor(0, 3); lcd.print(sensorOK ? "Status: Normal   " : "Status: Estimasi ");
      Serial.println("Suhu: " + String(suhuTubuh, 1) + "C");
    }
    delay(40);
  }

  if (hitungSuhu == 0) {
    suhuTubuh = suhuFallback;
    Serial.println("Estimasi suhu: " + String(suhuTubuh, 1) + "C");
  }
  Serial.println("Hasil suhu: " + String(suhuTubuh, 1) + "C");
  delay(300);
}

// ==================== UKUR BPM (30s) ====================
void ukurDetakJantungFixed() {
  int detik = 0;
  unsigned long start = millis();
  unsigned long lastPrint = millis();

  bpm_final = 0; lastBeat  = 0;

  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Deteksi BPM: 30s ");
  delay(300);

  while (millis() - start < durasi_ms) {
    sensorDetak.check();
    long irValue = sensorDetak.getIR();

    if (checkForBeat(irValue)) {
      long delta = millis() - lastBeat;
      lastBeat = millis();
      if (delta > 0) {
        beatsPerMinute = 60.0 / (delta / 1000.0);
        if (beatsPerMinute >= 40 && beatsPerMinute <= 180) {
          bpm_final = (int)beatsPerMinute;
        }
      }
    }

    if (millis() - lastPrint >= 1000 && detik < 30) {
      detik++; lastPrint += 1000;
      lcd.clear();
      lcd.setCursor(0, 0); lcd.print("BPM: " + String(bpm_final));
      lcd.setCursor(0, 1); lcd.print("T: " + String(detik) + "/30   ");
      Serial.print("Detik "); Serial.print(detik); Serial.print(" => BPM: "); Serial.println(bpm_final);
    }
    delay(10);
  }

  if (bpm_final == 0) bpm_final = detakFallback;
  detakJantungFinal = bpm_final;
  Serial.println("Hasil BPM: " + String(detakJantungFinal));
}

// ==================== UKUR SpO2 (30s) ====================
void ukurKadarOksigen() {
  int detik = 0;
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Deteksi SpO2:30s ");
  delay(300);

  for (int k = 0; k < UKURAN_BUFFER; k++) {
    sensorDetak.check();
    if (sensorDetak.available()) {
      bufferMerah[k] = sensorDetak.getRed();
      bufferIR[k]    = sensorDetak.getIR();
      sensorDetak.nextSample();
    } else {
      bufferMerah[k] = 100000 + random(-10000, 10000);
      bufferIR[k]    =  50000 + random(-5000,  5000);
    }
    delay(4);
  }

  unsigned long mulai = millis();
  unsigned long lastPrint = millis();

  while (millis() - mulai < durasi_ms) {
    for (int k = 0; k < UKURAN_BUFFER - 25; k++) {
      bufferMerah[k] = bufferMerah[k + 25];
      bufferIR[k]    = bufferIR[k + 25];
    }
    for (int k = UKURAN_BUFFER - 25; k < UKURAN_BUFFER; k++) {
      sensorDetak.check();
      if (sensorDetak.available()) {
        bufferMerah[k] = sensorDetak.getRed();
        bufferIR[k]    = sensorDetak.getIR();
        sensorDetak.nextSample();
      } else {
        bufferMerah[k] = 100000 + random(-10000, 10000);
        bufferIR[k]    =  50000 + random(-5000,  5000);
      }
      delay(2);
    }

    maxim_heart_rate_and_oxygen_saturation(
      bufferIR, UKURAN_BUFFER,
      bufferMerah,
      &spo2, &spo2Valid,
      &heartRate, &heartRateValid
    );
    if (spo2Valid == 1 && spo2 >= 70 && spo2 <= 100) {
      spo2Final = spo2;
    }

    if (millis() - lastPrint >= 1000 && detik < 30) {
      detik++; lastPrint += 1000;
      lcd.clear();
      lcd.setCursor(0, 0); lcd.print("SpO2: " + String(spo2Final) + "%   ");
      lcd.setCursor(0, 1); lcd.print("T: " + String(detik) + "/30   ");
      Serial.print("Detik "); Serial.print(detik); Serial.print(" => SpO2: "); Serial.println(spo2Final);
    }
    delay(10);
  }

  if (spo2Final == 0) spo2Final = spo2Fallback;
  Serial.println("Hasil SpO2: " + String(spo2Final) + "%");
}

// ==================== UKUR TEKANAN DARAH ====================
void ukurTekananDarahFixed() {
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Cek Tekanan Darah");
  Serial.println("=== TEKANAN DARAH ===");

  b_read = 0; b_discard = 0; i = 0; j = 0;

  const char spinner[4] = {'|','/','-','\\'};
  int spin = 0;
  const char HEADER[] = {'e','r','r',':','0'};
  int matchIdx = 0;

  lcd.setCursor(0, 1); lcd.print("Menunggu alat...");

  while (b_read == 0) {
    while (Serial2.available()) {
      char c = (char)Serial2.read();
      if (c == HEADER[matchIdx]) {
        matchIdx++;
        if (matchIdx == 5) { b_read = 1; break; }
      } else {
        matchIdx = (c == HEADER[0]) ? 1 : 0;
      }
    }
    lcd.setCursor(15, 1);
    lcd.print(spinner[(spin++) & 3]);
    delay(40);
  }

  lcd.setCursor(0, 1); lcd.print("Header: OK      ");

  while (i < 30) {
    if (Serial2.available()) {
      discard = Serial2.read();
      i++;
      if ((i % 5) == 0) {
        lcd.setCursor(0, 2); lcd.print("Buang: "); lcd.print(i); lcd.print("/30   ");
      }
    } else { delay(2); }
  }

  lcd.setCursor(0, 2); lcd.print("Ambil data...   ");
  while (j < 11) {
    if (Serial2.available()) {
      final_buff[j] = Serial2.read();
      j++;
      lcd.setCursor(12, 2); lcd.print(j); lcd.print("/11");
    } else { delay(2); }
  }

  int hexSys  = hexToDec(final_buff[0], final_buff[1]);
  int hexDias = hexToDec(final_buff[3], final_buff[4]);
  int hexBPM  = hexToDec(final_buff[9], final_buff[10]);

  nilaiSistolik   = hexSys  + KALIBRASI_SISTOLIK;
  nilaiDiastolik  = hexDias + KALIBRASI_DIASTOLIK;
  nilaiDetakDarah = hexBPM;

  Serial.println("SYS/DIA/BPM (kalibrasi): " + String(nilaiSistolik) + "/" + String(nilaiDiastolik) + " / " + String(nilaiDetakDarah));

  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("SYS: " + String(nilaiSistolik) + "   ");
  lcd.setCursor(0, 1); lcd.print("DIA: " + String(nilaiDiastolik) + "   ");
  lcd.setCursor(0, 2); lcd.print("BPM: " + String(nilaiDetakDarah) + "    ");
}

// ==================== HASIL AKHIR ====================
void tampilkanHasil() {
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("=== HASIL AKHIR ===");
  lcd.setCursor(0, 1); lcd.print("Suhu: " + String(suhuTubuh, 1) + "C   ");
  lcd.setCursor(0, 2); lcd.print("BPM : " + String(detakJantungFinal) + "    ");
  lcd.setCursor(0, 3); lcd.print("SpO2: " + String(spo2Final) + "%   ");
  delay(1000);

  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("SYS: " + String(nilaiSistolik) + " mmHg ");
  lcd.setCursor(0, 1); lcd.print("DIA: " + String(nilaiDiastolik) + " mmHg");
  lcd.setCursor(0, 2); lcd.print("NB : " + nbLabel + "      ");
  lcd.setCursor(0, 3); lcd.print("Rule: " + getStatusKesehatan());

  Serial.println("\n=== RINGKASAN ===");
  Serial.println("Suhu: " + String(suhuTubuh, 1) + "C");
  Serial.println("BPM : " + String(detakJantungFinal));
  Serial.println("SpO2: " + String(spo2Final) + "%");
  Serial.println("BP  : " + String(nilaiSistolik) + "/" + String(nilaiDiastolik) + " mmHg");
  Serial.println("NB  : " + nbLabel);
  Serial.println("Rule: " + getStatusKesehatan());
  Serial.println("==================");
  delay(900);
}

// ==================== RULE-BASED STATUS (opsional tampilan) ====================
// Suhu normal diset ke 36.0â€“38.0
String getStatusKesehatan() {
  int skor = 0;
  if (suhuTubuh >= 36.0 && suhuTubuh <= 38.0) skor += 25;
  else if (suhuTubuh >= 35.0 && suhuTubuh <= 38.5) skor += 15;

  if (detakJantungFinal >= 60 && detakJantungFinal <= 100) skor += 25;
  else if (detakJantungFinal >= 50 && detakJantungFinal <= 120) skor += 15;

  if (spo2Final >= 96) skor += 25;
  else if (spo2Final >= 90) skor += 15;

  if (nilaiSistolik >= 90 && nilaiSistolik <= 130 && nilaiDiastolik >= 60 && nilaiDiastolik <= 85) skor += 25;
  else if (nilaiSistolik >= 80 && nilaiSistolik <= 150 && nilaiDiastolik >= 50 && nilaiDiastolik <= 95) skor += 15;

  if (skor >= 85) return "Normal";
  if (skor >= 60) return "Kurang Normal";
  return "Berbahaya";
}

// ==================== KIRIM KE FIREBASE ====================
void kirimDataKeFirebaseFixed() {
  lcd.clear();
  lcd.setCursor(0, 0); lcd.print("Kirim ke server...");

  unsigned long waktuStampProper = ntpSinkron ? getNTPTime() : millis();

  StaticJsonDocument<896> doc;
  doc["waktu"]              = waktuStampProper;
  doc["perangkat"]          = DEVICE_ID;
  doc["suhu_tubuh"]         = String(suhuTubuh, 1);
  doc["detak_jantung"]      = String(detakJantungFinal);
  doc["kadar_oksigen"]      = String(spo2Final);
  doc["tekanan_sistolik"]   = String(nilaiSistolik);
  doc["tekanan_diastolik"]  = String(nilaiDiastolik);
  doc["prediksi_nb"]        = nbLabel;              // hasil model Gaussian NB
  doc["status_kesehatan"]   = getStatusKesehatan(); // rule-based (referensi)
  doc["waktu_baca"]         = getNTPTimestamp();

  String jsonString;
  serializeJson(doc, jsonString);

  String pathData   = "/data_kesehatan/data_" + String(waktuStampProper) + ".json";
  String urlData    = withAuth(pathData);
  String urlTerbaru = withAuth("/data_kesehatan/terbaru.json");

  WiFiClientSecure client; client.setInsecure();
  HTTPClient http;

  // simpan data
  if (http.begin(client, urlData)) {
    http.addHeader("Content-Type", "application/json");
    int kode = http.PUT(jsonString);
    lcd.setCursor(0, 1);
    lcd.print((kode == 200 || kode == 204) ? "Berhasil dikirim  " : ("Gagal kirim (" + String(kode) + ") "));
    http.end();
  }

  // update "terbaru"
  if (http.begin(client, urlTerbaru)) {
    http.addHeader("Content-Type", "application/json");
    int kode2 = http.PUT(jsonString);
    lcd.setCursor(0, 2);
    lcd.print((kode2 == 200 || kode2 == 204) ? "Real-time: OK     " : "Real-time: Gagal  ");
    http.end();
  }

  delay(800);
}

// ==================== NB: LOAD MODEL dari RTDB ====================
bool loadNBModelFromFirebase() {
  WiFiClientSecure client; client.setInsecure();
  HTTPClient http;

  // Coba beberapa path umum:
  const char* paths[] = {
    "/model/naive_bayes_model.json",
    "/naive_bayes_model.json",
    "/model/naive_bayes.json"
  };

  String payload;
  bool got = false;
  for (int p=0; p<3 && !got; p++) {
    String url = withAuth(paths[p]);
    if (!http.begin(client, url)) continue;
    int code = http.GET();
    if (code == 200) { payload = http.getString(); got = true; }
    http.end();
  }
  if (!got) { Serial.println("NB: model tidak ditemukan di RTDB"); return false; }

  StaticJsonDocument<12288> doc; // cukup besar untuk model
  DeserializationError err = deserializeJson(doc, payload);
  if (err) { Serial.println(String("NB: JSON parse error: ")+err.c_str()); return false; }

  // prior
  if (!doc.containsKey("prior") || !doc["prior"].is<JsonObject>()) {
    Serial.println("NB: prior tidak ditemukan"); return false;
  }
  JsonObject prior = doc["prior"].as<JsonObject>();
  // inisialisasi default (jaga-jaga)
  nbLogPrior[0] = nbLogPrior[1] = nbLogPrior[2] = logf(1.0f/3.0f);
  for (JsonPair kv : prior) {
    int cid = String(kv.key().c_str()).toInt(); // "0","1","2"
    float p  = kv.value().as<float>();
    if (cid>=0 && cid<NB_NUM_CLASSES && p>0.0f) nbLogPrior[cid] = logf(p);
  }

  // means
  if (!doc.containsKey("means") || !doc["means"].is<JsonObject>()) {
    Serial.println("NB: means tidak ditemukan"); return false;
  }
  JsonObject means = doc["means"].as<JsonObject>();

  auto readFeat = [&](JsonObject clsObj, int cid){
    // kunci harus sama persis dengan file:
    // "Suhu Tubuh (C)", "Detak Jantung", "Sistolik", "Diastolik", "Saturasi Oksigen"
    nbMean[cid][F_TEMP] = clsObj["Suhu Tubuh (C)"].as<float>();
    nbMean[cid][F_HR]   = clsObj["Detak Jantung"].as<float>();
    nbMean[cid][F_SYS]  = clsObj["Sistolik"].as<float>();
    nbMean[cid][F_DIA]  = clsObj["Diastolik"].as<float>();
    nbMean[cid][F_SPO2] = clsObj["Saturasi Oksigen"].as<float>();
  };

  for (JsonPair kv : means) {
    int cid = String(kv.key().c_str()).toInt();
    if (cid>=0 && cid<NB_NUM_CLASSES && kv.value().is<JsonObject>()) {
      readFeat(kv.value().as<JsonObject>(), cid);
    }
  }

  // std
  if (!doc.containsKey("std") || !doc["std"].is<JsonObject>()) {
    Serial.println("NB: std tidak ditemukan"); return false;
  }
  JsonObject stds = doc["std"].as<JsonObject>();

  auto readStd = [&](JsonObject clsObj, int cid){
    nbStd[cid][F_TEMP] = max( clsObj["Suhu Tubuh (C)"].as<float>(), 1e-3f );
    nbStd[cid][F_HR]   = max( clsObj["Detak Jantung"].as<float>(),  1e-3f );
    nbStd[cid][F_SYS]  = max( clsObj["Sistolik"].as<float>(),       1e-3f );
    nbStd[cid][F_DIA]  = max( clsObj["Diastolik"].as<float>(),      1e-3f );
    nbStd[cid][F_SPO2] = max( clsObj["Saturasi Oksigen"].as<float>(),1e-3f );
  };

  for (JsonPair kv : stds) {
    int cid = String(kv.key().c_str()).toInt();
    if (cid>=0 && cid<NB_NUM_CLASSES && kv.value().is<JsonObject>()) {
      readStd(kv.value().as<JsonObject>(), cid);
    }
  }

  // Debug ringkas
  Serial.println("NB: prior log:");
  Serial.println(String(" 0: ")+nbLogPrior[0]);
  Serial.println(String(" 1: ")+nbLogPrior[1]);
  Serial.println(String(" 2: ")+nbLogPrior[2]);

  return true;
}

// ==================== NB: GAUSSIAN PREDICT ====================
float logGaussian(float x, float mu, float sigma) {
  if (sigma < 1e-6f) sigma = 1e-6f;
  float var = sigma * sigma;
  // gunakan konstanta PI dari Arduino (float)
  return -0.5f * logf(2.0f * PI * var) - ((x - mu)*(x - mu)) / (2.0f * var);
}

int argmax3(float a, float b, float c) {
  if (a >= b && a >= c) return 0;
  if (b >= a && b >= c) return 1;
  return 2;
}

// NOTE PENTING:
// Model JSON kamu berisi mean & std "apa adanya" dari training.
// Kode ini MENGGUNAKAN LANGSUNG unit dari sensor (C, BPM, mmHg, %).
// Pastikan preprocessing di Colab kompatibel (tanpa scaler global).
String predictNB_Gaussian(float t, int bpm, int sys, int dia, int sO2) {
  float x[NB_NUM_FEATS] = { t, (float)bpm, (float)sys, (float)dia, (float)sO2 };

  float logPost[NB_NUM_CLASSES];
  for (int c=0;c<NB_NUM_CLASSES;c++) {
    float s = nbLogPrior[c];
    for (int f=0; f<NB_NUM_FEATS; f++) {
      s += logGaussian(x[f], nbMean[c][f], nbStd[c][f]);
    }
    logPost[c] = s;
  }

  int best = argmax3(logPost[0], logPost[1], logPost[2]);

  // Map class id -> label final
  return classIdToLabel(best);
}

// ==================== UTIL ====================
int hexDigit(char c) {
  if (c >= '0' && c <= '9') return c - '0';
  if (c >= 'A' && c <= 'F') return c - 'A' + 10;
  if (c >= 'a' && c <= 'f') return c - 'a' + 10;
  return 0;
}
int hexToDec(char high, char low) {
  return (hexDigit(high) << 4) | hexDigit(low);
}
String withAuth(const String& path) {
  String url = "https://" + FIREBASE_HOST + path;
  if (FIREBASE_AUTH.length() > 0) {
    url += (url.indexOf('?') >= 0 ? "&" : "?");
    url += "auth=" + FIREBASE_AUTH;
  }
  return url;
}
